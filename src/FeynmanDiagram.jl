
################################################################
"""
    prepare_qgraf_dat( model::Model, input::Dict{Any,Any} )

Prepare the model file for `QGRAF`.
"""
function prepare_qgraf_dat( model::Model, input::Dict{Any,Any} )
################################################################

  inc_part_list = map( s_ -> model.particle_name_dict[s_], input["incoming"] )
  inc_idx_str_list = map( i_ -> string(i_), eachindex(inc_part_list) )
  inc_mom_str_list = map( (i_,p_) -> is_massless(p_) ? p_.name*"[k"*i_*"]" : p_.name*"[K"*i_*"]", 
                          inc_idx_str_list, inc_part_list )

  n_inc = length(inc_part_list)
  out_part_list = map( s_ -> model.particle_name_dict[s_], input["outgoing"] )
  out_idx_str_list = map( i_ -> string(i_+n_inc), eachindex(out_part_list) )
  out_mom_str_list = map( (i_,p_) -> is_massless(p_) ? p_.name*"[k"*i_*"]" : p_.name*"[K"*i_*"]", 
                          out_idx_str_list, out_part_list )

  file = open( "qgraf.dat", "w" )
  write( file, 
    "output='qgraf_out.dat';\n"*
    "style='miracle.sty';\n"*
    "model='model.qgraf';\n"*
    "in = "*join( inc_mom_str_list, "," )*";\n"*
    "out = "*join( out_mom_str_list, "," )*";\n"*
    "loops = "*string(input["n_loop"]+input["QCDCT_order"])*";\n"*
    "loop_momentum = q;\n" )
  if input["DropTadpole"] == true && input["DropWFcorrection"] == true 
    write( file, 
    "options = notadpole, onshell;\n" )
  elseif input["DropTadpole"] == true && input["DropWFcorrection"] == false 
    write( file, 
    "options = notadpole;\n" )
  elseif input["DropTadpole"] == false && input["DropWFcorrection"] == true 
    write( file, 
    "options = onshell;\n" )
  else 
    write( file, 
    "options =;\n" )
  end # if
  write( file, 
    "true = vsum[ gspow, "*string(input["Amp_QCD_order"])*", "*string(input["Amp_QCD_order"])*"];\n"*
    "true = vsum[ epow, "*string(input["Amp_QED_order"])*", "*string(input["Amp_QED_order"])*"];\n"*
    "true = vsum[ qcdctpow, "*string(input["QCDCT_order"])*", "*string(input["QCDCT_order"])*"];\n" )
  close(file)

  file = open( "miracle.sty", "w" )
  write( file, """
<prologue>
#
# file generated by <program>
#
<command_loop><command_line_loop>#<command_data><end><end>#

FeynmanDiagrams:
<diagram>
- # Diagram<diagram_index>
  diagram_index: <diagram_index>
  symmetry_factor: <symmetry_factor>
  sign: <sign>1
  incoming_propagators:<in_loop>
    - # incoming particle <in_index>
      in_index: <in_index>
      vertex_index: <vertex_index>
      field: "<field>"
      field_index: <field_index>
      momentum: "<momentum>"<end>
  outgoing_propagators:<out_loop>
    - # outgoing particle <out_index>
      out_index: <out_index>
      vertex_index: <vertex_index>
      field: "<field>"
      field_index: <field_index>
      momentum: "<momentum>"<end>
  remnant_propagators:<propagator_loop> 
    - # internal or loop propagator <propagator_index>
      propagator_index: <propagator_index>
      birth_index: <dual-vertex_index>
      death_index: <vertex_index>
      field: "<field>"
      momentum: "<momentum>"<end>
  vertices:<vertex_loop>
    - # vertex <vertex_index>
      vertex_index: <vertex_index>
      momentum_product: [[<ray_loop>"(<momentum>)",<end><back>]]
      fields: [[<ray_loop>"<field>",<end><back>]]
      propagator_index_list: [[<ray_loop><propagator_index>,<end><back>]]<end>
<epilogue>


<exit>

  """)
  close(file)


end # function prepare_qgraf_dat


#######################################################################
"""
    generate_Feynman_diagram( model::Model, input::Dict{Any,Any} )

Interface to generating Feynman diagrams by using `QGRAF`.
"""
function generate_Feynman_diagram( model::Model, input::Dict{Any,Any} )
#######################################################################

  println()
  printstyled( "[Generate Feynman diagrams]\n", color=:green )

  prepare_qgraf_dat( model, input )

  if isfile( "qgraf_out.dat" ) == true
    rm( "qgraf_out.dat" )
  end # if
  run(`qgraf`)
  @assert isfile( "qgraf_out.dat" )

  rm( "qgraf.dat" )
  rm( "model.qgraf" )
  rm( "miracle.sty" )

end # function generate_Feynman_diagram





###################################################################################################
"""
    get_interaction( field_name_list::Vector{String}, model::Model )::Tuple{Interaction,Int64}

Based on `model.particle_name_dict`, get the interaction according to the link field name list.
"""
###################################################################################################
function get_interaction( field_name_list::Vector{String}, model::Model )::Tuple{Interaction,Int64}
###################################################################################################

  QCDct_link_name_list = filter( s_ -> s_ in ["QCDct1","QCDct2"], field_name_list )
  QCDct_order = length( QCDct_link_name_list )

  normal_link_name_list = filter( s_ -> (s_ in ["QCDct1","QCDct2"]) == false, field_name_list ) 
  normal_link_kf_list = map( s_ -> model.particle_name_dict[s_].kf, normal_link_name_list )
  sorted_normal_link_kf_list = sort( normal_link_kf_list )
  inter = model.sorted_kf_list_dict[sorted_normal_link_kf_list]

  return inter, QCDct_order
end # function get_interaction
#################################################




###########################################################################################################
"""
    get_incoming_couplings_lorentz_list( part::Particle, mark::Int64, momentum::Basic )::Vector{Basic}

Produce the Basic expression for the incoming particles, which can be spinors or polarization vectors.
"""
function get_incoming_couplings_lorentz_list( part::Particle, mark::Int64, momentum::Basic )::Vector{Basic}
###########################################################################################################

  if part.spin == :fermion && part.kf > 0 
    return [ Basic(" SpU( $mark, spb$mark, $momentum, r$mark, $(part.mass) ) ") ]
  elseif part.spin == :fermion && part.kf < 0
    return [ Basic(" SpVB( $mark, spb$mark, $momentum, r$mark, $(part.mass) ) ") ]
  elseif part.spin == :vector
    return [ Basic(" VecEps( $mark, mub$mark, $momentum, r$mark, $(part.mass) ) ") ]
  elseif part.spin == :scalar
    return [ Basic("1") ]
  else
    @assert false "We should have not considered ghost in external field."
  end # if

end # function get_incoming_couplings_lorentz_list


###########################################################################################################
"""
    get_outgoing_couplings_lorentz_list( part::Particle, mark::Int64, momentum::Basic )::Vector{Basic}

Produce the Basic expression for the outgoing particles, which can be spinors or polarization vectors.
"""
function get_outgoing_couplings_lorentz_list( part::Particle, mark::Int64, momentum::Basic )::Vector{Basic}
###########################################################################################################

  if part.spin == :fermion && part.kf > 0
    return [ Basic(" SpUB( $mark, spa$mark, $momentum, r$mark, $(part.mass) ) ") ]
  elseif part.spin == :fermion && part.kf < 0
    return [ Basic(" SpV( $mark, spa$mark, $momentum, r$mark, $(part.mass) ) ") ]
  elseif part.spin == :vector
    return [ Basic(" VecEpsC( $mark, mua$mark, $momentum, r$mark, $(part.mass) ) ") ]
  elseif part.spin == :scalar
    return [ Basic("1") ]
  else
    error( "We should have not considered ghost in external field.\n" )
  end # if

end # function get_outgoing_couplings_lorentz_list


##########################################################################################################
"""
    get_remnant_couplings_lorentz_list( part::Particle, mark::Int64, momentum::Basic, use_unitary_gauge::Bool )::Vector{Basic}

Produce the Basic expression for the internal/loop propagator particles.
"""
function get_remnant_couplings_lorentz_list( part::Particle, mark::Int64, momentum::Basic, use_unitary_gauge::Bool )::Vector{Basic}
##########################################################################################################

  if part.spin == :fermion
    #return [ Basic(" I*( GAij(spb$mark,spa$mark,$momentum)+ONEij(spb$mark,spa$mark)*$(part.mass) )*Den($momentum,$(part.mass),$(part.width)) ") ]
    return [ Basic(" I*GAij(spb$mark,spa$mark,$momentum,$(part.mass))*Den($momentum,$(part.mass),$(part.width)) ") ]
  elseif part.spin == :vector && is_massless(part) == true 
    return [ Basic(" (-1)*I*LMT(mua$mark,mub$mark)*Den($momentum,0,0) ") ]
  elseif part.spin == :vector && is_massless(part) == false 
    if use_unitary_gauge == true 
      return [ Basic(" (-1)*I*Den($momentum,$(part.mass),$(part.width))*( LMT(mua$mark,mub$mark)-FV($momentum,mua$mark)*FV($momentum,mub$mark)*$(part.mass)^(-2) ) ") ]
    else
      return [ Basic(" (-1)*I*LMT(mua$mark,mub$mark)*Den($momentum,$(part.mass),$(part.width)) ") ]
    end # if
  elseif part.spin in [:scalar, :ghost]
    return [ Basic(" I*Den( $momentum, $(part.mass), $(part.width) ) ") ]
  else 
    error( "We should have not considered ghost in external field.\n" )
  end # if

end # function get_remnant_couplings_lorentz_list



###########################################################################################
"""
    edge_from_link_index( vert::ExVertex, link_index::Int64, g::GenericGraph )::ExEdge

Get the ExEdge according to the link_index in the ExVertex `vert` in the GenericGraph `g`.
"""
function edge_from_link_index( vert::ExVertex, link_index::Int64, g::GenericGraph )::ExEdge
###########################################################################################

  edge_list = edges(g)
  propagator_index = vert.attributes["propagator_index_list"][link_index]
  edge_idx = findfirst( e_ -> e_.attributes["propagator_index"] == propagator_index, edge_list )
  edge = edge_list[edge_idx]

  return edge
end # function edge_from_link_index


###########################################################################################
"""
    vertex_from_mark( mark::Int64, g::GenericGraph )::ExVertex

Get the ExVertex according to the `mark` in the GenericGraph `g`.
"""
function vertex_from_mark( mark::Int64, g::GenericGraph )::ExVertex
###########################################################################################

  vertex_list = vertices(g)
  vertex_idx = findfirst( v_ -> v_.attributes["mark"] == mark, vertex_list )
  vert = vertex_list[vertex_idx]

  return vert
end # function vertex_from_mark

###########################################################################################
"""
    vertex_from_label( label::String, g::GenericGraph )::ExVertex

Get the ExVertex according to the `label` in the GenericGraph `g`.
"""
function vertex_from_label( label::String, g::GenericGraph )::ExVertex
###########################################################################################

  vertex_list = vertices(g)
  vertex_idx = findfirst( v_ -> v_.label == label, vertex_list )
  vert = vertex_list[vertex_idx]

  return vert
end # function vertex_from_label



#################################################################################
"""
    get_link_color( g::GenericGraph, vert::ExVertex, link_index::Int64, part_list::Vector{Particle} )::Basic

Generate the Basic expression symbol for the color index for the `link_index` in ExVertex `vert` in GenercGraph `g`.
"""
function get_link_color( g::GenericGraph, vert::ExVertex, link_index::Int64, part_list::Vector{Particle} )::Basic
################################################################################

  in_edge_list = in_edges( vert, g )
  out_edge_list = out_edges( vert, g )

  if link_index < 0
    link_color = Basic("clv$(vert.attributes["mark"]*100+abs(link_index))")
  else 
    link_edge = edge_from_link_index( vert, link_index, g )
    death_color = link_edge.attributes["death_COLOR"]
    birth_color = link_edge.attributes["birth_COLOR"]

    part = part_list[link_index]
    # This is for W+/W- like, although in SM there is only gluon will have this kind of color factor.
    link_color = link_edge in in_edge_list ? death_color : birth_color
    # Then what if gluon or Z-like
    if link_edge in in_edge_list && link_edge in out_edge_list 
      link_color = part.kf > 0 ? death_color : birth_color
      if is_neutral(part)
        propagator_index = vert.attributes["propagator_index_list"][link_index]
        first_pos = findfirst( x_ -> x_ == propagator_index,  vert.attributes["propagator_index_list"] )
        link_color = first_pos == link_index ? death_color : birth_color
      end # if
    end # if
  end # if 

  return link_color
end # function get_link_color


#########################################################################################
"""
    translate_color_factor( one_color::Basic, vert::ExVertex, g::GenericGraph, part_list::Vector{Particle} )::Basic

Combine the generic color `one_color` expression with the specific ExVertex `vert`, and produce the color factor for this vertex in this diagram.
"""
function translate_color_factor( one_color::Basic, vert::ExVertex, g::GenericGraph, part_list::Vector{Particle} )::Basic
#########################################################################################

  @funs Identity DeltaFun DeltaAdj T SUNT f SUNF

  color_str = string(one_color)
  new_color = one_color

  range_list = findall( r"Identity\([+-]*\d+, [+-]*\d+\)", color_str )
  Identity_str_list = map( r_ -> color_str[r_], range_list ) 

  for one_Identity_str in Identity_str_list 
    args = get_args( Basic(one_Identity_str) )
    link1_index, link2_index = convert(Int64,args[1]), convert(Int64,args[2])

    # It is not possible that both of link1_index and link2_index are negative (dummy).
    @assert link1_index > 0 || link2_index > 0 
    if link1_index > 0 
      edge1or2 = edge_from_link_index( vert, link1_index, g )
    elseif link2_index > 0
      edge1or2 = edge_from_link_index( vert, link2_index, g )
    else 
      @assert false
    end # if

    # This first case is considering the tadpole sunset diagram.
    if link1_index == link2_index
      color1, color2 = edge1or2.attributes["birth_COLOR"], edge1or2.attributes["death_COLOR"]
    # Then in the other case, we need to consider the case with dummy index.
    else
      color1 = get_link_color( g, vert, link1_index, part_list )
      color2 = get_link_color( g, vert, link2_index, part_list )
    end # if
    
    edge1or2_color = edge1or2.attributes["particle"].color
    @assert edge1or2_color != :singlet
    new_color = subs( new_color, Basic(one_Identity_str), 
                      edge1or2_color == :triplet ? DeltaFun(color1,color2) : DeltaAdj(color1,color2) )
  end # for one_Identity_str

  range_list = findall( r"[Tf]+\([+-]*\d+, [+-]*\d+, [+-]*\d+\)", color_str )
  Tf_str_list = map( r_ -> color_str[r_], range_list ) 

  for one_Tf_str in Tf_str_list 
    args = get_args( Basic(one_Tf_str) )
    link1_index, link2_index, link3_index = convert(Int64,args[1]), convert(Int64,args[2]), convert(Int64,args[3])

    # It is not possible that all of link1_index and link2_index and link3_index are negative (dummy).
    @assert link1_index > 0 || link2_index > 0 || link3_index > 0

    # two of [link1_index,link2_index,link3_index] are same 
    if link1_index == link2_index
      edge12 = edge_from_link_index( vert, link1_index, g )
      color1, color2 = edge12.attributes["birth_COLOR"], edge12.attributes["death_COLOR"]
      color3 = get_link_color( g, vert, link3_index, part_list )
    elseif link1_index == link3_index
      edge13 = edge_from_link_index( vert, link1_index, g )
      color1, color3 = edge13.attributes["birth_COLOR"], edge13.attributes["death_COLOR"]
      color2 = get_link_color( g, vert, link2_index, part_list )
    elseif link2_index == link3_index
      edge23 = edge_from_link_index( vert, link2_index, g )
      color2, color3 = edge23.attributes["birth_COLOR"], edge23.attributes["death_COLOR"]
      color1 = get_link_color( g, vert, link1_index, part_list )
    # Then none of them are same.
    else
      color1 = get_link_color( g, vert, link1_index, part_list )
      color2 = get_link_color( g, vert, link2_index, part_list )
      color3 = get_link_color( g, vert, link3_index, part_list )
    end # if
    
    new_color = subs( new_color, Basic(one_Tf_str), Basic("SUN"*uppercase(one_Tf_str[1])*"($color1,$color2,$color3)") )
  end # for one_T_str

  return new_color
end # function translate_color_factor



######################################################################################
"""
    get_link_lorentz( g::GenericGraph, vert::ExVertex, link_index::Int64, part_list::Vector{Particle} )::Basic

Generate the Basic expression symbol for the Lorentz index for the `link_index` in ExVertex `vert` in GenercGraph `g`.
"""
function get_link_lorentz( g::GenericGraph, vert::ExVertex, link_index::Int64, part_list::Vector{Particle} )::Basic
######################################################################################

  in_edge_list = in_edges( vert, g )
  out_edge_list = out_edges( vert, g )

  if link_index < 0
    link_lor = Basic("muv$(vert.attributes["mark"]*100+abs(link_index))")
  else 
    link_edge = edge_from_link_index( vert, link_index, g )
    death_lor = link_edge.attributes["death_LORENTZ"]
    birth_lor = link_edge.attributes["birth_LORENTZ"]

    part = part_list[link_index]
    # This is for W+/W-
    link_lor = link_edge in in_edge_list ? death_lor : birth_lor
    # Then what if gluon or Z
    if link_edge in in_edge_list && link_edge in out_edge_list
      link_lor = part.kf > 0 ? death_lor : birth_lor
      if is_neutral(part)
        propagator_index = vert.attributes["propagator_index_list"][link_index]
        first_pos = findfirst( x_ -> x_ == propagator_index,  vert.attributes["propagator_index_list"] )
        link_lor = first_pos == link_index ? death_lor : birth_lor
      end # if
    end # if
  end # if 

  return link_lor
end # function get_link_lorentz


#######################################################################################
"""
    get_link_momentum( g::GenericGraph, vert::ExVertex, link_index::Int64 )::Basic

Generate the Basic expression symbol for the momentum for the `link_index` in ExVertex `vert` in GenercGraph `g`.
"""
function get_link_momentum( g::GenericGraph, vert::ExVertex, link_index::Int64 )::Basic
#######################################################################################

  in_edge_list = in_edges( vert, g )

  @assert link_index > 0
  link_edge = edge_from_link_index( vert, link_index, g )
  # momentum is flow out in UFO Feynman rules
  link_momentum = ( link_edge in in_edge_list ? (-1) : 1 ) * link_edge.attributes["momentum"]

  return link_momentum
end # function get_link_momentum



#####################################################################################
"""
    get_link_spinor( g::GenericGraph, vert::ExVertex, link_index::Int64 )::Basic

Generate the Basic expression symbol for the external spinors for the `link_index` in ExVertex `vert` in GenercGraph `g`.
"""
function get_link_spinor( g::GenericGraph, vert::ExVertex, link_index::Int64 )::Basic
#####################################################################################

  in_edge_list = in_edges( vert, g )

  if link_index < 0
    link_spinor = Basic("spv$(vert.attributes["mark"]*100+abs(link_index))")
  else 
    link_edge = edge_from_link_index( vert, link_index, g )
    link_spinor = link_edge in in_edge_list ? link_edge.attributes["death_SPINOR"] : link_edge.attributes["birth_SPINOR"]
  end # if 

  return link_spinor
end # function get_link_spinor





################################################################################################
"""
    translate_lorentz_factor( one_lorentz::Basic, vert::ExVertex, g::GenericGraph, part_list::Vector{Particle} )::Basic

Combine the generic Lorentz factor `one_lorentz` expression with the specific ExVertex `vert`, and produce the Lorentz factor for this vertex in this diagram.
"""
function translate_lorentz_factor( one_lorentz::Basic, vert::ExVertex, g::GenericGraph, part_list::Vector{Particle} )::Basic
################################################################################################

  @funs Metric LMT P FV Gamma GAij ProjP PRij ProjM PLij Identity ONEij 

  if one_lorentz == P(1, 2)*Metric(2, 3) - P(1, 3)*Metric(2, 3) - P(2, 1)*Metric(1, 3) + P(2, 3)*Metric(1, 3) + P(3, 1)*Metric(1, 2) - P(3, 2)*Metric(1, 2)
    edge1 = edge_from_link_index( vert, 1, g )
    edge2 = edge_from_link_index( vert, 2, g )
    edge3 = edge_from_link_index( vert, 3, g )
    lor1 = get_link_lorentz( g, vert, 1, part_list )
    lor2 = get_link_lorentz( g, vert, 2, part_list )
    lor3 = get_link_lorentz( g, vert, 3, part_list )
    mom1 = get_link_momentum( g, vert, 1 )
    mom2 = get_link_momentum( g, vert, 2 )
    mom3 = get_link_momentum( g, vert, 3 )
    new_lorentz = FV(mom2-mom3,lor1)*LMT(lor2,lor3) + FV(mom3-mom1,lor2)*LMT(lor3,lor1) + FV(mom1-mom2,lor3)*LMT(lor1,lor2)
    return new_lorentz
  end # if

  lorentz_str = string(one_lorentz)
  new_lorentz = one_lorentz

  range_list = findall( r"Metric\([+-]*\d+, [+-]*\d+\)", lorentz_str )
  Metric_str_list = map( r_ -> lorentz_str[r_], range_list ) 
  for one_Metric_str in Metric_str_list
    args = get_args( Basic(one_Metric_str) )
    link1_index, link2_index = convert(Int64,args[1]), convert(Int64,args[2])
    @assert link1_index > 0 && link2_index > 0
    if link1_index > 0 
      edge1or2 = edge_from_link_index( vert, link1_index, g )
    elseif link2_index > 0
      edge1or2 = edge_from_link_index( vert, link2_index, g )
    else 
      @assert false
    end # if

    if link1_index == link2_index
      lor1, lor2 = edge1or2.attributes["birth_LORENTZ"], edge1or2.attributes["death_LORENTZ"]
    else
      lor1 = get_link_lorentz( g, vert, link1_index, part_list )
      lor2 = get_link_lorentz( g, vert, link2_index, part_list )
    end # if

    new_lorentz = subs( new_lorentz, Basic(one_Metric_str), LMT(lor1,lor2) )
  end # for one_Metric_str

  range_list = findall( r"P\([+-]*\d+, [+-]*\d+\)", lorentz_str )
  P_str_list = map( r_ -> lorentz_str[r_], range_list ) 
  for one_P_str in P_str_list
    args = get_args( Basic(one_P_str) )
    link1_index, link2_index = convert(Int64,args[1]), convert(Int64,args[2])

    lor1 = get_link_lorentz( g, vert, link1_index, part_list )
    mom2 = get_link_momentum( g, vert, link2_index )
    new_lorentz = subs( new_lorentz, Basic(one_P_str), FV(mom2,lor1) )
  end # for one_P_str

  range_list = findall( r"Gamma\([+-]*\d+, [+-]*\d+, [+-]*\d+\)", lorentz_str )
  Gamma_str_list = map( r_ -> lorentz_str[r_], range_list ) 
  for one_Gamma_str in Gamma_str_list
    args = get_args( Basic(one_Gamma_str) )
    link1_index, link2_index, link3_index = convert(Int64,args[1]), convert(Int64,args[2]), convert(Int64,args[3])

    lor1 = get_link_lorentz( g, vert, link1_index, part_list )
    sp2 = get_link_spinor( g, vert, link2_index )
    sp3 = get_link_spinor( g, vert, link3_index )

    new_lorentz = subs( new_lorentz, Basic(one_Gamma_str), GAij(sp2,sp3,lor1) )
  end # for one_Gamma_str

  range_list = findall( r"ProjP\([+-]*\d+, [+-]*\d+\)", lorentz_str )
  ProjP_str_list = map( r_ -> lorentz_str[r_], range_list ) 
  for one_ProjP_str in ProjP_str_list
    args = get_args( Basic(one_ProjP_str) )
    link1_index, link2_index = convert(Int64,args[1]), convert(Int64,args[2])

    sp1 = get_link_spinor( g, vert, link1_index )
    sp2 = get_link_spinor( g, vert, link2_index )

    new_lorentz = subs( new_lorentz, Basic(one_ProjP_str), PRij(sp1,sp2) )
  end # for one_ProjP_str

  range_list = findall( r"ProjM\([+-]*\d+, [+-]*\d+\)", lorentz_str )
  ProjM_str_list = map( r_ -> lorentz_str[r_], range_list ) 
  for one_ProjM_str in ProjM_str_list
    args = get_args( Basic(one_ProjM_str) )
    link1_index, link2_index = convert(Int64,args[1]), convert(Int64,args[2])

    sp1 = get_link_spinor( g, vert, link1_index )
    sp2 = get_link_spinor( g, vert, link2_index )

    new_lorentz = subs( new_lorentz, Basic(one_ProjM_str), PLij(sp1,sp2) )
  end # for one_ProjM_str

  range_list = findall( r"Identity\([+-]*\d+, [+-]*\d+\)", lorentz_str )
  Identity_str_list = map( r_ -> lorentz_str[r_], range_list ) 
  for one_Identity_str in Identity_str_list
    args = get_args( Basic(one_Identity_str) )
    link1_index, link2_index = convert(Int64,args[1]), convert(Int64,args[2])

    sp1 = get_link_spinor( g, vert, link1_index )
    sp2 = get_link_spinor( g, vert, link2_index )

    new_lorentz = subs( new_lorentz, Basic(one_Identity_str), ONEij(sp1,sp2) )
  end # for one_Identity_str

  return new_lorentz
end # function translate_lorentz_factor




###################################################
"""
    canonicalize_loop_mom( mom::Basic )::Basic

Canonicalize the loop momenta.
"""
function canonicalize_loop_mom( mom::Basic )::Basic
###################################################

  @vars q1, q2, q3

  q1_coeff = coeff(mom,q1)
  if q1_coeff == Basic(1)
    return mom
  end # if
  if q1_coeff == Basic(-1)
    return expand(-mom)
  end # if

  @assert q1_coeff == 0
  q2_coeff = coeff(mom,q2)
  if q2_coeff == Basic(1)
    return mom
  end # if
  if q2_coeff == Basic(-1)
    return expand(-mom)
  end # if

  @assert q2_coeff == 0
  q3_coeff = coeff(mom,q3)
  if q3_coeff == Basic(1)
    return mom
  end # if
  if q3_coeff == Basic(-1)
    return expand(-mom)
  end # if

  error( "This should not happen! mom is $(mom)" )

  return mom

end # function canonicalize_loop_mom







######################################################################################################
"""
    convert_qgraf_TO_Graph( one_qgraf::Dict{Any,Any}, model::Model )::Union{GenericGraph,Nothing}

Convert the diagram read from QGRAF into the GenericGraph in Julia.
"""
function convert_qgraf_TO_Graph( one_qgraf::Dict{Any,Any}, model::Model )::Union{GenericGraph,Nothing}
######################################################################################################

  # Check if there is CT vertex and if the QCDct field is properly used for CT graphs.
  # QCDct1 and QCDct2 should have same end-points as designed.
  QCDct_propagators = filter( p_ -> p_["field"] in ["QCDct1","QCDct2"], one_qgraf["remnant_propagators"] )
  invalid_propagator_pos = findfirst( p_ -> p_["birth_index"] != p_["death_index"], QCDct_propagators )
  if invalid_propagator_pos != nothing 
    printstyled( "Found one invalid diagram!\n", color=:red )
    return nothing
  end # if

  g = graph( ExVertex[], ExEdge[] )  
  v0 = ExVertex(0,"graph property")
  add_vertex!(g,v0)
  ## Diagram index
  v0.attributes["diagram_index"] = one_qgraf["diagram_index"] 
  ## Read-in symmetry_factor.
  v0.attributes["symmetry_factor"] = one_qgraf["symmetry_factor"] 
  ## Read-in sign of this diagram. 
  ## The sign from QGRAF is combination of anti-commutivative field (fermion,ghost,QCDct1,QCDct2...) loops,
  ##   and the way open fermionic/ghost lines connect those external fields.
  ## Also correct the sign if there is QCDct1 or QCDct2, 
  ##   since they are defined as anti-commutative fields to avoid changing symmetry factor.
  n_QCDct = length( QCDct_propagators )
  v0.attributes["sign"] = one_qgraf["sign"]*(-1)^n_QCDct
  ## For sake of function vertex_from_mark, we also need "mark" for v0
  v0.attributes["mark"] = 0
  ## For filtering the "style"
  v0.attributes["style"] = ""

  qgraf_incoming_propagators = one_qgraf["incoming_propagators"]
  n_inc = length(qgraf_incoming_propagators)
  qgraf_outgoing_propagators = one_qgraf["outgoing_propagators"]
  n_out = length(qgraf_outgoing_propagators)

  ## For distinguishing incoming and outgoing edges
  v0.attributes["n_inc"] = n_inc
  v0.attributes["n_out"] = n_out



  ## Add incoming vertices.
  for one_inc in qgraf_incoming_propagators
    vert_idx = num_vertices(g) # There is v0 ahead already.
    inc_v = ExVertex( vert_idx, "v$vert_idx" )
    inc_v.attributes = Dict(
      "mark" => one_inc["in_index"],
      "style" => "External",
      "interaction" => nothing,
      "QCDct_order" => 0,
      "color_list" => [1],
      "couplings_lorentz_list" => [1]
    ) # end Dict
    add_vertex!( g, inc_v ) 
  end # for one_inc


  # Add outgoing vertices.
  for one_out in qgraf_outgoing_propagators
    vert_idx = num_vertices(g) # There is v0 ahead already.
    out_v = ExVertex( vert_idx, "v$vert_idx" )
    out_v.attributes = Dict(
      "mark" => one_out["out_index"]+n_inc,
      "style" => "External",
      "interaction" => nothing,
      "QCDct_order" => 0,
      "color_list" => [1],
      "couplings_lorentz_list" => [1] 
    ) # end Dict
    add_vertex!( g, out_v ) 
  end # for one_out


  #  Add internal or loop vertices.
  qgraf_vertices = one_qgraf["vertices"]
  for one_vert in qgraf_vertices
    vert_idx = num_vertices(g) # There is v0 ahead already.
    int_v = ExVertex( vert_idx, "v$vert_idx" )

    # Get interaction and QCDct_order
    inter, QCDct_order = get_interaction( one_vert["fields"], model )
    
    #-----------------------------------------------------------------------------------------------
    # Now we need to re-order the list "propagator_index_list" associated with one_vert["fields"] (source)
    #     according to the vertex Feynman rule "inter.link_list" (destination).
    #-----------------------------------------------------------------------------------------------
    src_part_name_list = one_vert["fields"] # source list of particle names
    p_src = sortperm( src_part_name_list )
    dst_part_name_list = map( p_ -> p_.name, inter.link_list ) # destination list of particle names
    p_dst = sortperm( dst_part_name_list )
    invp_dst = invperm( p_dst )
    @assert src_part_name_list[p_src][invp_dst] == dst_part_name_list
    feynrules_index_list = one_vert["propagator_index_list"][p_src][invp_dst] 

    # color_list and couplings_lorentz_list will be generated later.
    int_v.attributes = Dict(
      "mark" => one_vert["vertex_index"]+n_inc+n_out,
      "style" => "Internal",
      "interaction" => inter,
      "QCDct_order" => QCDct_order,
      "propagator_index_list" => feynrules_index_list,
      "color_list" => nothing,
      "couplings_lorentz_list" => nothing 
    ) # end Dict
    add_vertex!( g, int_v ) 
  end # for one_vert


  # Add incoming propagators.
  # It could be u(kf>0) or vbar(kf<0) for fermion, epsilon_\mu for vector, 1 for scalar.
  for one_inc in qgraf_incoming_propagators
    in_index = one_inc["in_index"]
    vert_index = one_inc["vertex_index"]+n_inc+n_out
    field_name = one_inc["field"]
    field_part = model.particle_name_dict[field_name]

    in_v = vertex_from_mark( in_index, g )
    vert_v = vertex_from_mark( vert_index, g )

    new_edge = ExEdge( num_edges(g)+1, in_v, vert_v )

    mark = in_index
    momentum = Basic(one_inc["momentum"])
    couplings_lorentz_list = get_incoming_couplings_lorentz_list( field_part, mark, momentum )

    new_edge.attributes = Dict( 
      "mark" => mark,
      "particle" => field_part,
      "style" => "External",
      "propagator_index" => one_inc["field_index"],
      "momentum" => momentum,
      "ref2_MOM" => Basic("r$mark"),
      "null_MOM" => Basic("k$mark"),
      "birth_LORENTZ" => Basic("mua$mark"), "birth_COLOR" => Basic("cla$mark"), "birth_SPINOR" => Basic("spa$mark"),
      "death_LORENTZ" => Basic("mub$mark"), "death_COLOR" => Basic("clb$mark"), "death_SPINOR" => Basic("spb$mark"),
      "color_list" => [ Basic("1") ],
      "couplings_lorentz_list" => couplings_lorentz_list 
    ) # end Dict

    add_edge!( g, new_edge )
  end # for one_inc


  # Add outgoing propagaotrs.
  # It could be ubar(kf>0) or v(kf<0) for fermion, epsilon_\mu^* for vector, 1 for scalar.
  for one_out in qgraf_outgoing_propagators
    out_index = one_out["out_index"]+n_inc
    vert_index = one_out["vertex_index"]+n_inc+n_out
    field_name = one_out["field"]
    field_part = model.particle_name_dict[field_name]

    vert_v = vertex_from_mark( vert_index, g )
    out_v = vertex_from_mark( out_index, g )

    new_edge = ExEdge( num_edges(g)+1, vert_v, out_v )

    mark = out_index
    momentum = Basic(one_out["momentum"])
    couplings_lorentz_list = get_outgoing_couplings_lorentz_list( field_part, mark, momentum )

    new_edge.attributes = Dict(
      "mark" => mark,
      "particle" => field_part,
      "style" => "External",
      "propagator_index" => one_out["field_index"],
      "momentum" => momentum,
      "ref2_MOM" => Basic("r$mark"),
      "null_MOM" => Basic("k$mark"),
      "birth_LORENTZ" => Basic("mua$mark"), "birth_COLOR" => Basic("cla$mark"), "birth_SPINOR" => Basic("spa$mark"),
      "death_LORENTZ" => Basic("mub$mark"), "death_COLOR" => Basic("clb$mark"), "death_SPINOR" => Basic("spb$mark"),
      "color_list" => [ Basic("1") ],
      "couplings_lorentz_list" => couplings_lorentz_list 
    ) # end Dict

    add_edge!( g, new_edge )
  end # for one_out


  # Filter out the "QCDct1" and "QCDct2" propagators.
  qgraf_remnant_propagators = one_qgraf["remnant_propagators"]
  true_remnant_propagators = filter( rem_ -> (rem_["field"] in ["QCDct1","QCDct2"]) == false, qgraf_remnant_propagators )
  # Add internal and loop propagators.
  for one_rem in true_remnant_propagators
    mark = one_rem["propagator_index"]+n_inc+n_out
    birth_index = one_rem["birth_index"]+n_inc+n_out
    death_index = one_rem["death_index"]+n_inc+n_out
    field_name = one_rem["field"]
    field_part = model.particle_name_dict[field_name]

    birth_v = vertex_from_mark( birth_index, g )
    death_v = vertex_from_mark( death_index, g )

    new_edge = field_part.kf > 0 ? ExEdge( num_edges(g)+1, birth_v, death_v ) : ExEdge( num_edges(g)+1, death_v, birth_v )

    momentum = sign(field_part.kf)*Basic(one_rem["momentum"])

    style_str = findfirst("q",one_rem["momentum"]) == nothing ? "Internal" : "Loop"
    if style_str == "Loop"
      momentum = canonicalize_loop_mom(momentum)
    end # if

    id_color_dict = Dict( :triplet => [ Basic(" DeltaFun(clb$mark,cla$mark) ") ], 
                          :octet   => [ Basic(" DeltaAdj(clb$mark,cla$mark) ") ],
                          :singlet => [ Basic("1") ] )

    couplings_lorentz_list = get_remnant_couplings_lorentz_list( field_part, mark, momentum, model.unitary_gauge )

    new_edge.attributes = Dict( 
      "mark" => mark,
      "particle" => model.particle_kf_dict[abs(field_part.kf)],
      "style" => style_str,
      "propagator_index" => one_rem["propagator_index"], 
      "momentum" => momentum,
      "ref2_MOM" => Basic("0"),
      "null_MOM" => Basic("0"),
      "birth_LORENTZ" => Basic("mua$mark"), "birth_COLOR" => Basic("cla$mark"), "birth_SPINOR" => Basic("spa$mark"),
      "death_LORENTZ" => Basic("mub$mark"), "death_COLOR" => Basic("clb$mark"), "death_SPINOR" => Basic("spb$mark"),
      "color_list" => id_color_dict[field_part.color],
      "couplings_lorentz_list" => couplings_lorentz_list 
    ) # end Dict
    
    add_edge!( g, new_edge )
  end # for one_rem



# #-------------------------------------------------------------------
# # For convenience, we create indexing Dict for the edges according to :propagator_index
# propagator_index_pair_list = map( e_ -> get_prop(mg,e_,:propagator_index) => e_ , edges( mg ) )
# propagator_index_dict = Dict{Int64,Edge}( collect(propagator_index_pair_list) )
# set_prop!( mg, :propagator_index_dict, propagator_index_dict )
  #-------------------------------------------------------------------
  # Now the structure of this graph has been digested into Graph.
  # Then we can evaluate color_row_list and couplings_lorentz_col_list for the internal or loop vertices.
  #-------------------------------------------------------------------
  internal_vertex_list = filter( v_ -> v_.attributes["style"] == "Internal", vertices(g) )
  for vert in internal_vertex_list
    inter = vert.attributes["interaction"]

    new_color_row_list = map( color_ -> translate_color_factor(color_,vert,g,inter.link_list), inter.color_row_list )

    new_lorentz_col_list = map( lor_ -> translate_lorentz_factor(lor_,vert,g,inter.link_list), inter.lorentz_col_list )

    n_row, n_col = size( inter.couplings_matrix )
    new_couplings_lorentz_list = Array{Basic,1}(undef,n_row)
    @vars CTorder
    for r_ in 1:n_row
      new_couplings_lorentz_list[r_] = 0
      for c_ in 1:n_col
        if vert.attributes["QCDct_order"] == 0 
          new_couplings_lorentz_list[r_] += subs(inter.couplings_matrix[r_,c_],CTorder,0)*new_lorentz_col_list[c_]
        else 
          new_couplings_lorentz_list[r_] += coeff( expand(inter.couplings_matrix[r_,c_]), CTorder^(vert.attributes["QCDct_order"]) )*new_lorentz_col_list[c_]
        end # if
      end # for c_
    end # for r_

    vert.attributes["color_list"] = new_color_row_list
    vert.attributes["couplings_lorentz_list"] = new_couplings_lorentz_list
  end # for vert 

  return g

end # function convert_qgraf_TO_Graph



###########################################
"""
    tensor_product( ex_list1::Union{Vector{Basic},Vector{Int64}}, ex_list2::Union{Vector{Basic},Vector{Int64}})::Vector{Basic}

tensor_product( x, y ): 
x and y are two string lists/arrays.
This function calculate the tensor production of two arrays.
"""
function tensor_product( 
    ex_list1::Union{Vector{Basic},Vector{Int64}}, 
    ex_list2::Union{Vector{Basic},Vector{Int64}}
)::Vector{Basic}
###########################################
  res = Vector{Basic}()
  for ex1 in ex_list1, ex2 in ex_list2
    push!(res,ex1*ex2)
  end
  return res

end # function tensor_product




###################################################################
"""
    assemble_amplitude( g::GenericGraph )::Tuple{Vector{Basic},Vector{Basic}}

Now this graph can be evaluated according to the values of the propagators and vertices.
"""
function assemble_amplitude( g::GenericGraph )::Tuple{Vector{Basic},Vector{Basic}}
###################################################################

  amp_color_list = Basic[1]
  amp_couplings_lorentz_list = Basic[1]
  for vert in vertices(g)
    if vert.label == "graph property"
      continue
    end # if
    amp_color_list = tensor_product( amp_color_list, vert.attributes["color_list"] )
    amp_couplings_lorentz_list = tensor_product( amp_couplings_lorentz_list, vert.attributes["couplings_lorentz_list"] )
  end # for vert

  for edge in edges(g)
    amp_color_list = tensor_product( amp_color_list, edge.attributes["color_list"] )
    amp_couplings_lorentz_list = tensor_product( amp_couplings_lorentz_list, edge.attributes["couplings_lorentz_list"] )
  end # for edge

  return amp_color_list, amp_couplings_lorentz_list;

end # function assemble_amplitude




###############################################################
"""
    generate_scale2_list( g::GenericGraph, kin_relation::Dict{Basic,Basic} )::Vector{Basic}

Collect all the symbols that are the squares of scales.
"""
function generate_scale2_list( g::GenericGraph, kin_relation::Dict{Basic,Basic} )::Vector{Basic}
###############################################################

  ver_mass_list = Vector{Basic}()
  #-----------------------
  for one_pair in kin_relation
    if get_name( one_pair[1] ) == "Den"
      continue
    end # if
    ver_mass_list = vcat( ver_mass_list, free_symbols( one_pair[2] ) )
  end # for one_pair

  #-----------------------
  for one_edge in edges(g)
    mass = one_edge.attributes["particle"].mass
    if mass == 0
      continue
    end # if
    ver_mass_list = vcat( ver_mass_list, mass )
  end # for one_edge

  #-----------------------
  unique!( ver_mass_list )


  #-----------------------
  scale2_list = Vector{Basic}( undef, length(ver_mass_list) )
  for index in 1:length(ver_mass_list)
    ver_mass_str = string(ver_mass_list[index])
    if ver_mass_str[1] == 'm'
      scale2_list[index] = ver_mass_list[index]^2
    else 
      scale2_list[index] = ver_mass_list[index]
    end # if
  end # for index

  return scale2_list

end # function generate_scale2_list













##############################################################################################################################
"""
    factor_out_loop_den( g::GenericGraph, lorentz_list::Vector{Basic} )::Tuple{Vector{Basic},Vector{Basic},Vector{Int64}}

Factorize out the loop propagator denominators, so that the `lorentz_list` can become shorter. And then they can be handled separately.
"""
function factor_out_loop_den( g::GenericGraph, lorentz_list::Vector{Basic} )::Tuple{Vector{Basic},Vector{Basic},Vector{Int64}}
##############################################################################################################################

  @funs Den

  loop_edge_list = filter( e_ -> e_.attributes["style"] == "Loop", edges(g) )

  den_prod = Basic(1)
  width_den_prod = Basic(1)
  for one_edge in loop_edge_list
    mom = one_edge.attributes["momentum"]
    mass = one_edge.attributes["particle"].mass
    width = one_edge.attributes["particle"].width
    # For now we only consider the width of loop propagator is zero.
    den_prod *= Den( mom, mass, 0 ) 
    width_den_prod *= Den( mom, mass, width ) 
  end # for one_edge

  new_lorentz_list = map( x_ -> expand(x_/width_den_prod), lorentz_list )

  @assert SymEngine.get_symengine_class(den_prod) == :Mul || den_prod == 1 || get_name(den_prod) == "Den"
  factor_list = get_args(den_prod)
  if SymEngine.get_symengine_class(den_prod) == :FunctionSymbol && get_name(den_prod) == "Den" 
    factor_list = Basic[ den_prod ]
  end # if
  n_factor = length(factor_list)
  loop_den_list = Vector{Basic}( undef, n_factor )
  loop_den_xpt_list = Vector{Int64}( undef, n_factor )
  for index in 1:n_factor
    one_factor = factor_list[index]
    if SymEngine.get_symengine_class(one_factor) == :FunctionSymbol && get_name(one_factor) == "Den"
      loop_den_list[index] = one_factor
      loop_den_xpt_list[index] = 1
    elseif SymEngine.get_symengine_class(one_factor) == :Pow && get_name(get_args(one_factor)[1]) == "Den"
      loop_den_list[index] = get_args(one_factor)[1]
      loop_den_xpt_list[index] = convert( Int64, get_args(one_factor)[2] )
    else
      error( "Not expected: "*string(one_factor) )
    end # if
  end # for index

  return new_lorentz_list, loop_den_list, loop_den_xpt_list

end # function factor_out_loop_den





##################################################################################
"""
    contract_Dirac_indices( g::GenericGraph, lorentz_expr_list::Vector{Basic} )::Vector{Basic}

Contract the Dirac indices in the `lorentz_expr_list` by using FORM scripts.
"""
function contract_Dirac_indices( g::GenericGraph, lorentz_expr_list::Vector{Basic} )::Vector{Basic}
##################################################################################

  diagram_index = vertex_from_label("graph property",g).attributes["diagram_index"]

  new_lorentz_expr_list = Vector{Basic}( undef, length(lorentz_expr_list) )
  for index in 1:length(lorentz_expr_list)
    lorentz_expr = lorentz_expr_list[index]
    file_name = "contract_lorentz_expr$(index)_diagram$(diagram_index)"
    form_script_str = make_amp_contraction_script( lorentz_expr, file_name )

    file = open( file_name*".frm", "w" )
    write( file, form_script_str )
    close(file)

    #printstyled( "[ form $(file_name).frm in thread #$(Threads.threadid()) ]\n", color=:yellow )
    printstyled( "[ form $(file_name).frm ]\n", color=:yellow )
    run( pipeline( `form $(file_name).frm`, file_name*".log" ) )

    file = open( file_name*".out", "r" )
    result_str = read( file, String )
    close( file )
    result_expr = Basic(result_str)
    new_lorentz_expr_list[index] = result_expr

    rm( file_name*".frm" )
    rm( file_name*".out" )
    rm( file_name*".log" )

  end # for index

  return new_lorentz_expr_list

end # function contract_Dirac_indices







##################################################################################
"""
    contract_Dirac_indices_noexpand( g::GenericGraph, lorentz_expr_list::Vector{Basic} )::Vector{Basic}

Contract the Dirac indices in the `lorentz_expr_list` by using FORM scripts, but do not expand the amplitudes.
"""
function contract_Dirac_indices_noexpand( g::GenericGraph, lorentz_expr_list::Vector{Basic} )::Vector{Basic}
##################################################################################

  diagram_index = vertex_from_label("graph property",g).attributes["diagram_index"]

  new_lorentz_expr_list = Vector{Basic}( undef, length(lorentz_expr_list) )
  for index in 1:length(lorentz_expr_list)
    lorentz_expr = lorentz_expr_list[index]
    file_name = "contract_lorentz_expr$(index)_diagram$(diagram_index)_noexpand"
    form_script_str = make_amp_contraction_noexpand_script( lorentz_expr, file_name )

    file = open( file_name*".frm", "w" )
    write( file, form_script_str )
    close(file)

    printstyled( "[ form $(file_name).frm ]\n", color=:yellow )
    run( pipeline( `form $(file_name).frm`, file_name*".log" ) )

    file = open( file_name*".out", "r" )
    result_str = read( file, String )
    close( file )
    result_expr = Basic(result_str)
    new_lorentz_expr_list[index] = result_expr

    rm( file_name*".frm" )
    rm( file_name*".out" )
    rm( file_name*".log" )

  end # for index

  return new_lorentz_expr_list

end # function contract_Dirac_indices_noexpand




#####################################################################################################################################
"""
    check_consistency( diagram_index::Int64, lorentz_list::Vector{Basic}, lorentz_noexpand_list::Vector{Basic}, ext_mom_list::Vector{Basic}, kin_relation::Dict{Basic,Basic} )::Nothing

Check if the contraction for the amplitude can be consistent with the results obtained from the Mathematica script.
"""
function check_consistency( diagram_index::Int64, lorentz_list::Vector{Basic}, lorentz_noexpand_list::Vector{Basic}, 
                            ext_mom_list::Vector{Basic}, kin_relation::Dict{Basic,Basic} )::Nothing
#####################################################################################################################################

  @funs SP

  sp_relation_list = filter( pair_ -> get_name(pair_[1]) == "SP", kin_relation )
  n_sp_relation = length(sp_relation_list)
  kin_relation_str_set = Set{String}()
  for one_sp_relation ∈ sp_relation_list
    sp = one_sp_relation[1]
    mom1 = get_args(sp)[1]
    mom2 = get_args(sp)[2]
    sp_expr = one_sp_relation[2] 

    push!( kin_relation_str_set, "SP[$(mom1),$(mom2)] -> $(sp_expr)" )
    if mom1 != mom2 
      push!( kin_relation_str_set, "SP[$(mom2),$(mom1)] -> $(sp_expr)" )
    end # if
  end # for one_mom

  n_lorentz = length( lorentz_list )
  @assert n_lorentz == length( lorentz_noexpand_list )

  for lorentz_index ∈ 1:n_lorentz
    one_lorentz = lorentz_list[lorentz_index]
    one_lorentz_noexpand = lorentz_noexpand_list[lorentz_index]

    file_name = "check_diagram$(diagram_index)_lorentz$(lorentz_index)"

    file = open( file_name*".m", "w" )
    write( file, """
expr1 = $( gen_mma_str(one_lorentz) );
expr2 = $( gen_mma_str(one_lorentz_noexpand) );


MomList = {q1,q2,q3,$(join(map(string,ext_mom_list),","))};
vanishing = Map[# :> 0 &, MomList];

dummyList = {epsMU1,epsMU2,epsMU3,epsMU4,epsMU5,dummyMU1,dummyMU2,dummyMU3,dummyMU4,dummyMU5,dummyMU6,dummyMU7,dummyMU8,dummyMU9,dummyMU10};
nuList = {NU1,NU2,NU3,NU4,NU5,NU6,NU7,NU8,NU10,NU12,NU13,NU14,NU15,NU16,NU17,NU18,NU19,NU20};
muList = {MU1,MU2,MU3,MU4,MU5,MU6,MU7,MU8,MU10,MU12,MU13,MU14,MU15,MU16,MU17,MU18,MU19,MU20};

makeSP[ mom1_, mom2_ ] := If[ AlphabeticOrder[ ToString[mom1], ToString[mom2] ] == 1, SP[mom1,mom2], SP[mom2,mom1] ];

expr2 = expr2 //. DiracTrace[ x1___, GA[mom_/;Coefficient[mom,unity]=!=0], x2___ ] :> DiracTrace[x1,GA[mom/.unity:>0],x2] + Coefficient[mom,unity]*DiracTrace[x1,x2];

expr2 = expr2 //. { DiracTrace[ x___, PL, GA[mom_], y___ ] :> DiracTrace[ x, GA[mom], PR, y ],
                    DiracTrace[ x___, PR, GA[mom_], y___ ] :> DiracTrace[ x, GA[mom], PL, y ],
                    DiracTrace[ x___, PL, PL ] :> DiracTrace[ x, PL ],
                    DiracTrace[ x___, PR, PR ] :> DiracTrace[ x, PR ],
                    DiracTrace[ x___, PL, PR ] :> 0,
                    DiracTrace[ x___, PR, PL ] :> 0
                  };

expr2 = expr2 //. { DiracTrace[ GA[mu1_], PL ] :> 0,
                    DiracTrace[ GA[mu1_], PR ] :> 0,
                    DiracTrace[ GA[mu1_], GA[mu2_], GA[mu3_], PL ] :> 0,
                    DiracTrace[ GA[mu1_], GA[mu2_], GA[mu3_], PR ] :> 0,
                    DiracTrace[ GA[mu1_], GA[mu2_], GA[mu3_], GA[mu4_], GA[mu5_], PL ] :> 0,
                    DiracTrace[ GA[mu1_], GA[mu2_], GA[mu3_], GA[mu4_], GA[mu5_], PR ] :> 0,
                    DiracTrace[ GA[mu1_] ] :> 0,
                    DiracTrace[ GA[mu1_], GA[mu2_], GA[mu3_] ] :> 0,
                    DiracTrace[ GA[mu1_], GA[mu2_], GA[mu3_], GA[mu4_], GA[mu5_] ] :> 0
                  };

expr2 = expr2 //.{ DiracTrace[x1___, GA[mom_/;(mom/.vanishing) == 0], x2___] :> DiracTrace[x1,GA[nuList[[Length[{x1}]+1]]],x2]*FV[mom,nuList[[Length[{x1}]+1]]] };
expr2 = expr2 /. { DiracTrace[ GA[mu1_], GA[mu2_] ] :> 4*LMT[mu1,mu2],
                   DiracTrace[ GA[mu1_], GA[mu2_], GA[mu3_], GA[mu4_] ] :> 4*(LMT[mu1,mu4]*LMT[mu2,mu3]-LMT[mu1,mu3]*LMT[mu2,mu4]+LMT[mu1,mu2]*LMT[mu3,mu4]),
                   DiracTrace[ GA[mu1_], GA[mu2_], GA[mu3_], GA[mu4_], GA[mu5_], GA[mu6_] ] :> 4*(LMT[mu1, mu6]*LMT[mu2, mu5]*LMT[mu3, mu4] - LMT[mu1, mu5]*LMT[mu2, mu6]*LMT[mu3, mu4] - LMT[mu1, mu6]*LMT[mu2, mu4]*LMT[mu3, mu5] + LMT[mu1, mu4]*LMT[mu2, mu6]*LMT[mu3, mu5] + LMT[mu1, mu5]*LMT[mu2, mu4]*LMT[mu3, mu6] - LMT[mu1, mu4]*LMT[mu2, mu5]*LMT[mu3, mu6] + LMT[mu1, mu6]*LMT[mu2, mu3]*LMT[mu4, mu5] - LMT[mu1, mu3]*LMT[mu2, mu6]*LMT[mu4, mu5] + LMT[mu1, mu2]*LMT[mu3, mu6]*LMT[mu4, mu5] - LMT[mu1, mu5]*LMT[mu2, mu3]*LMT[mu4, mu6] + LMT[mu1, mu3]*LMT[mu2, mu5]*LMT[mu4, mu6] - LMT[mu1, mu2]*LMT[mu3, mu5]*LMT[mu4, mu6] + LMT[mu1, mu4]*LMT[mu2, mu3]*LMT[mu5, mu6] - LMT[mu1, mu3]*LMT[mu2, mu4]*LMT[mu5, mu6] + LMT[mu1, mu2]*LMT[mu3, mu4]*LMT[mu5, mu6]), 
                   DiracTrace[ PL ] :> 2,
                   DiracTrace[ PR ] :> 2,
                   DiracTrace[ GA[mu1_], GA[mu2_], PL ] :> 2*LMT[mu1,mu2],
                   DiracTrace[ GA[mu1_], GA[mu2_], PR ] :> 2*LMT[mu1,mu2],
                   DiracTrace[ GA[mu1_], GA[mu2_], GA[mu3_], GA[mu4_], PL ] :> 2*(LMT[mu1,mu4]*LMT[mu2,mu3]-LMT[mu1,mu3]*LMT[mu2,mu4]+LMT[mu1,mu2]*LMT[mu3,mu4]) + 2*im*Levi[mu1,mu2,mu3,mu4],
                   DiracTrace[ GA[mu1_], GA[mu2_], GA[mu3_], GA[mu4_], PR ] :> 2*(LMT[mu1,mu4]*LMT[mu2,mu3]-LMT[mu1,mu3]*LMT[mu2,mu4]+LMT[mu1,mu2]*LMT[mu3,mu4]) - 2*im*Levi[mu1,mu2,mu3,mu4]
                 };


expr2 = Expand[expr2] //. { FermionChain[ x1__, GA[mu_], x2__ ] * FV[mom_,mu_] :> FermionChain[ x1, GA[mom], x2 ],
                    FermionChain[ x1__, GA[mu1_], x2__ ] * LMT[mu1_,mu2_] :> FermionChain[ x1, GA[mu2], x2 ],
                    FermionChain[ x1__, GA[mu1_], x2__ ] * LMT[mu2_,mu1_] :> FermionChain[ x1, GA[mu2], x2 ],
                    FV[mom_,mu1_] * LMT[mu1_,mu2_] :> FV[mom,mu2],
                    FV[mom_,mu1_] * LMT[mu2_,mu1_] :> FV[mom,mu2] };

expr2 = expr2 //. FermionChain[ x1__, GA[mom_/;Coefficient[mom,unity]=!=0], x2__ ] :> FermionChain[x1,GA[mom/.unity:>0],x2] + Coefficient[mom,unity]*FermionChain[x1,x2];

expr2 = expr2 //. FermionChain[x1__, GA[mom_ /; ! MemberQ[MomList, mom] && (mom /. vanishing) == 0], x2__] :> Map[FermionChain[x1, GA[#], x2] &, MomList].((Normal[CoefficientArrays[mom, MomList]])[[2]]);

expr2 = expr2 //. FV[ mom_ /; ! MemberQ[MomList, mom] && (mom /. vanishing) == 0, mu_ ] :> Map[FV[#, mu] &, MomList].((Normal[CoefficientArrays[mom, MomList]])[[2]]);

expr2 = expr2 //. SP[ mom1_ /; ! MemberQ[MomList, mom1] && (mom1 /. vanishing) == 0, mom2_ ] :> Map[makeSP[#, mom2] &, MomList].((Normal[CoefficientArrays[mom1, MomList]])[[2]]);

expr2 = expr2 //. SP[ mom1_, mom2_ /; ! MemberQ[MomList, mom2] && (mom2 /. vanishing) == 0 ] :> Map[makeSP[mom1, #] &, MomList].((Normal[CoefficientArrays[mom2, MomList]])[[2]]);

expr2 = expr2 //. { FermionChain[x1__, GA[mom_], PL, x2__] :> FermionChain[x1, PR, GA[mom], x2], 
                    FermionChain[x1__, GA[mom_], PR, x2__] :> FermionChain[x1, PL, GA[mom], x2],
                    FermionChain[x1__, PL, PL, x2__ ] :> FermionChain[x1, PL, x2 ],
                    FermionChain[x1__, PR, PR, x2__ ] :> FermionChain[x1, PR, x2 ],
                    FermionChain[x1__, PL, PR, x2__ ] :> 0,
                    FermionChain[x1__, PR, PL, x2__ ] :> 0
                  };

expr2 = Expand[expr2] //. { FermionChain[ x1__, GA[mom_/; MemberQ[MomList, mom]], GA[mom_/; MemberQ[MomList, mom]], x2__ ] :> SP[mom,mom]*FermionChain[x1,x2],
                            FermionChain[ x1__, GA[mu_/; ! MemberQ[MomList, mu]], GA[mu_/; ! MemberQ[MomList, mu]], x2__ ] :> diim*FermionChain[x1,x2],
                            FermionChain[ x1__, GA[mu_/; ! MemberQ[MomList, mu]], GA[mom_], GA[mu_/; ! MemberQ[MomList, mu]], x2__ ] :> (2-diim)*FermionChain[x1,GA[mom],x2],
                            FV[mom1_,mu_]*FV[mom2_,mu_] :> makeSP[mom1,mom2],
                            FV[mom_,mu_]^2 :> SP[mom,mom] };

expr2 = expr2 //. {$( join(collect(kin_relation_str_set),",") )};

expr2 = expr2 //. FermionChain[ x1__, GA[mu_/; MemberQ[dummyList, mu]], x__, GA[mu_/; MemberQ[dummyList, mu]], x2__ ] :> FermionChain[ x1, GA[muList[[Length[{x1}]]]], x, GA[muList[[Length[{x1}]]]], x2 ];

expr2 = expr2 //. { FV[mom_,mu_]*VecEps[int_, mu_, mom_, ref_, mass_] :> 0, FV[mom_,mu_]*VecEpsC[int_, mu_, mom_, ref_, mass_] :> 0,
                    FermionChain[ x__, GA[mom_], U[int_,mom_,ref_,0] ] :> 0, FermionChain[ x__, GA[mom_], V[int_,mom_,ref_,0] ] :> 0,
                    FermionChain[ UB[int_,mom_,ref_,0], PL, GA[mom_], x__ ] :> 0, FermionChain[ VB[int_,mom_,ref_,0], PL, GA[mom_], x__ ] :> 0, 
                    FermionChain[ UB[int_,mom_,ref_,0], PR, GA[mom_], x__ ] :> 0, FermionChain[ VB[int_,mom_,ref_,0], PR, GA[mom_], x__ ] :> 0,
                    FermionChain[ UB[int_,mom_,ref_,0], GA[mom_], x__ ] :> 0, FermionChain[ VB[int_,mom_,ref_,0], GA[mom_], x__ ] :> 0,
                    FermionChain[ x__, GA[mom_], U[int_,mom_,ref_,0] ] :> 0, FermionChain[ x__, GA[mom_], V[int_,mom_,ref_,0] ] :> 0,
                    FermionChain[ x__, GA[mom_], PL, U[int_,mom_,ref_,0] ] :> 0, FermionChain[ x__, GA[mom_], PL, V[int_,mom_,ref_,0] ] :> 0,
                    FermionChain[ x__, GA[mom_], PR, U[int_,mom_,ref_,0] ] :> 0, FermionChain[ x__, GA[mom_], PR, V[int_,mom_,ref_,0] ] :> 0
                   };

expr1 = expr1 //. { FermionChain[ x1__, GA[mu_], x2__ ] * FV[mom_,mu_] :> FermionChain[ x1, GA[mom], x2 ], 
                    FermionChain[ x1__, GA[mu1_], x2__ ] * LMT[mu1_,mu2_] :> FermionChain[ x1, GA[mu2], x2 ],
                    FermionChain[ x1__, GA[mu1_], x2__ ] * LMT[mu2_,mu1_] :> FermionChain[ x1, GA[mu2], x2 ],
                    FV[mom_,mu1_] * LMT[mu1_,mu2_] :> FV[mom,mu2],
                    FV[mom_,mu1_] * LMT[mu2_,mu1_] :> FV[mom,mu2],
                    FV[mom1_,mu_]*FV[mom2_,mu_] :> makeSP[mom1,mom2],
                    FV[mom_,mu_]^2 :> SP[mom,mom]
                  };

expr1 = expr1 //. { FermionChain[ x1__, GA[mom_/; MemberQ[MomList, mom]], GA[mom_/; MemberQ[MomList, mom]], x2__ ] :> SP[mom,mom]*FermionChain[x1,x2],
                    FermionChain[ x1__, GA[mu_/; ! MemberQ[MomList, mu]], GA[mu_/; ! MemberQ[MomList, mu]], x2__ ] :> diim*FermionChain[x1,x2],
                    FermionChain[ x1__, GA[mu_/; ! MemberQ[MomList, mu]], GA[mom_], GA[mu_/; ! MemberQ[MomList, mu]], x2__ ] :> (2-diim)*FermionChain[x1,GA[mom],x2]
                  };

expr1 = expr1 //. {$( join(collect(kin_relation_str_set),",") )};

expr1 = expr1 //. FermionChain[ x1__, GA[mu_/; MemberQ[dummyList, mu]], x__, GA[mu_/; MemberQ[dummyList, mu]], x2__ ] :> FermionChain[ x1, GA[muList[[Length[{x1}]]]], x, GA[muList[[Length[{x1}]]]], x2 ];

expr1 = expr1 //. { FV[mom_,mu_]*VecEps[int_, mu_, mom_, ref_, mass_] :> 0, FV[mom_,mu_]*VecEpsC[int_, mu_, mom_, ref_, mass_] :> 0,
                    FermionChain[ x__, GA[mom_], U[int_,mom_,ref_,0] ] :> 0, FermionChain[ x__, GA[mom_], V[int_,mom_,ref_,0] ] :> 0,
                    FermionChain[ UB[int_,mom_,ref_,0], PL, GA[mom_], x__ ] :> 0, FermionChain[ VB[int_,mom_,ref_,0], PL, GA[mom_], x__ ] :> 0, 
                    FermionChain[ UB[int_,mom_,ref_,0], PR, GA[mom_], x__ ] :> 0, FermionChain[ VB[int_,mom_,ref_,0], PR, GA[mom_], x__ ] :> 0,
                    FermionChain[ UB[int_,mom_,ref_,0], GA[mom_], x__ ] :> 0, FermionChain[ VB[int_,mom_,ref_,0], GA[mom_], x__ ] :> 0,
                    FermionChain[ x__, GA[mom_], U[int_,mom_,ref_,0] ] :> 0, FermionChain[ x__, GA[mom_], V[int_,mom_,ref_,0] ] :> 0,
                    FermionChain[ x__, GA[mom_], PL, U[int_,mom_,ref_,0] ] :> 0, FermionChain[ x__, GA[mom_], PL, V[int_,mom_,ref_,0] ] :> 0,
                    FermionChain[ x__, GA[mom_], PR, U[int_,mom_,ref_,0] ] :> 0, FermionChain[ x__, GA[mom_], PR, V[int_,mom_,ref_,0] ] :> 0
                   };

Levi0[a__] := Signature[{a}] (Levi0 @@ Sort@{a}) /; ! OrderedQ[{a}];
Levi0[a__] := 0 /; ! Unequal[a];

expr2 = expr2 //. { Levi[mu1_,mu2_,mu3_,mu4_]*FV[mom_,mu1_] :> Levi[mom,mu2,mu3,mu4],
                    Levi[mu1_,mu2_,mu3_,mu4_]*FV[mom_,mu2_] :> Levi[mu1,mom,mu3,mu4],
                    Levi[mu1_,mu2_,mu3_,mu4_]*FV[mom_,mu3_] :> Levi[mu1,mu2,mom,mu4],
                    Levi[mu1_,mu2_,mu3_,mu4_]*FV[mom_,mu4_] :> Levi[mu1,mu2,mu3,mom]
                   };

diff = (expr1-expr2) //. Levi[a__] -> Levi0[a] //Expand;

stream=OpenWrite["$(file_name).out"];
Write[ stream, diff ];
Close[stream];

""" )
    close(file)


    #printstyled( "  run MathKernel -script $(file_name).m ... \n", color=:green )
    #println( "  Start @", Dates.now() )
    run( pipeline( `MathKernel -script $(file_name).m`, file_name*".log" ) )
    #println( "  Done @", Dates.now() )
    printstyled( "  Done MathKernel -script $(file_name).m in thread #$(Threads.threadid()) \n", color=:green )
  
    file = open( file_name*".out", "r" )
    result_str = replace( read( file, String ), r"\s"=>"" )
    close(file)
    printstyled( "  $(file_name).out has length $(length(result_str))\n", color=:red )

    #@assert Basic(result_str) == 0
  
    #rm( file_name*".m" )
    rm( file_name*".log" )
    #rm( file_name*".out" )

  end # for lorentz_index



end # function check_consistency








###################################################################################################
"""
    simplify_color_factors( g::GenericGraph, color_factor_list::Vector{Basic} )::Vector{Basic}

Simplify the color factors by using FORM scripts.
"""
function simplify_color_factors( g::GenericGraph, color_factor_list::Vector{Basic} )::Vector{Basic}
###################################################################################################

  diagram_index = vertex_from_label("graph property",g).attributes["diagram_index"]

  new_color_factor_list = Vector{Basic}( undef, length(color_factor_list) )
  for index in 1:length(color_factor_list)
    one_color_factor = color_factor_list[index]
    file_name = "simplify_color_factor$(index)_diagram$(diagram_index)"
    form_script_str = make_simplify_color_factor_script( one_color_factor, file_name )

    file = open( file_name*".frm", "w" )
    write( file, form_script_str )
    close(file)

    #printstyled( "[ form $(file_name).frm in thread #$(Threads.threadid()) ]\n", color=:yellow )
    printstyled( "[ form $(file_name).frm ]\n", color=:yellow )
    run( pipeline( `form $(file_name).frm`, file_name*".log" ) )

    file = open( file_name*".out", "r" )
    result_str = read( file, String )
    close( file )
    result_expr = Basic(result_str)
    new_color_factor_list[index] = result_expr

    run( `rm $(file_name).frm $(file_name).out $(file_name).log` )
  end # for index

  return new_color_factor_list

end # function simplify_color_factors



###########################################################################################################
"""
    write_out_amplitude( n_loop::Int64, diagram_index::Int64, couplingfactor::Basic, parameter_dict::Dict{Basic,Basic}, ext_mom_list::Vector{Basic}, scale2_list::Vector{Basic}, kin_relation::Dict{Basic,Basic}, baseINC_script_str::String, amp_color_list::Vector{Basic}, amp_lorentz_list::Vector{Basic}, loop_den_list::Vector{Basic}, loop_den_xpt_list::Vector{Int64}, min_eps_xpt::Int64, max_eps_xpt::Int64, the_lock::ReentrantLock )::Nothing

Write out the amplitude information into the file that can be read easily.
"""
function write_out_amplitude( n_loop::Int64, diagram_index::Int64, couplingfactor::Basic, parameter_dict::Dict{Basic,Basic}, 
    ext_mom_list::Vector{Basic}, scale2_list::Vector{Basic}, kin_relation::Dict{Basic,Basic}, baseINC_script_str::String, 
    amp_color_list::Vector{Basic}, amp_lorentz_list::Vector{Basic}, 
    loop_den_list::Vector{Basic}, loop_den_xpt_list::Vector{Int64},
    min_eps_xpt::Int64, max_eps_xpt::Int64, the_lock::ReentrantLock )::Nothing
###########################################################################################################


  printstyled( "[ Generate amplitude_diagram$(diagram_index).out ]\u264e\n", color=:green, bold=true )
  amp_file = open( "amplitudes/amplitude_diagram$(diagram_index).out", "w" )
  write( amp_file, 
    "n_loop: $(n_loop)\n"*
    "couplingfactor: $(couplingfactor)\n"*
    "ext_mom_list: $(ext_mom_list)\n"*
    "scale2_list: $(scale2_list)\n"*
    "Diagram #$(diagram_index): \n"*
    "  Denominators: \n" )
  for one_den in loop_den_list
    write( amp_file, 
    "    $(one_den)\n" )
  end # for one_den

  write( amp_file, 
    "Kinematics Relations: \n" )
  for one_pair in kin_relation
    write( amp_file, 
    "  "*string(one_pair)*"\n" )
  end # for one_pair

  write( amp_file, 
    "Color Factors: \n" )
  for ii in 1:length(amp_color_list)
    one_color = amp_color_list[ii]
    write( amp_file, 
    "  amp_color #$(ii): \n"*
    "    $(one_color); \n" )
  end # for ii

  write( amp_file, 
    "Lorentz Factors: \n" )
  for ii in 1:length(amp_lorentz_list)
    one_val = amp_lorentz_list[ii]
    write( amp_file, 
    "  amp_lorentz #$(ii): \n"* 
    "    $( expand(one_val/couplingfactor) ); \n" )
  end # for ii

  write( amp_file, 
    "Model Parameters: \n" )
  for one_pair in parameter_dict
    write( amp_file, 
    "  "*string(one_pair)*"\n" )
  end # for one_pair

  close( amp_file )

  if isfile( "amplitudes/amplitude_diagram$(diagram_index).jld" )
    rm( "amplitudes/amplitude_diagram$(diagram_index).jld" )
  end # if

  jldopen( "amplitudes/amplitude_diagram$(diagram_index).jld", "w" ) do file 
    write( file, "n_loop", n_loop )
    write( file, "min_eps_xpt", min_eps_xpt )
    write( file, "max_eps_xpt", max_eps_xpt )
    write( file, "couplingfactor", string(couplingfactor) )
    write( file, "ext_mom_list", map( string, ext_mom_list ) )
    write( file, "scale2_list", map( string, scale2_list ) )
    write( file, "loop_den_list",  map( string, loop_den_list ) )
    write( file, "loop_den_xpt_list", loop_den_xpt_list )
    write( file, "kin_relation", map( p_->(string(p_[1]),string(p_[2])), collect(kin_relation) ) )
    write( file, "baseINC_script_str", baseINC_script_str )
    write( file, "model_parameter_dict", map( p_->(string(p_[1]),string(p_[2])), collect(parameter_dict) ) )
    write( file, "amp_color_list",  map( string, amp_color_list ) )
    write( file, "amp_lorentz_list",  map( string, amp_lorentz_list ) )
  end # file

  return nothing

end # function write_out_amplitude

#########################################################################
"""
    write_out_visual_graph( g::GenericGraph, model::Model, couplingfactor::Basic, color_list::Vector{Basic}, lorentz_list::Vector{Basic}, ext_mom_list::Vector{Basic}, scale2_list::Vector{Basic} )::Nothing

Write out the diagrams into the file that can be complied or read easily.
"""
function write_out_visual_graph( g::GenericGraph, model::Model, 
    couplingfactor::Basic, color_list::Vector{Basic}, lorentz_list::Vector{Basic},
    ext_mom_list::Vector{Basic}, scale2_list::Vector{Basic} )::Nothing
#########################################################################

  diagram_index = vertex_from_label("graph property",g).attributes["diagram_index"]

  graph_str = generate_visual_graph( g, model )

  couplingfactor_str = convert_couplingfactor( diagram_index, couplingfactor )
  color_str_list = convert_color_list( diagram_index, color_list )
  lorentz_str_list = convert_lorentz_list( diagram_index, lorentz_list, ext_mom_list, scale2_list )

  printstyled( "[ Generate visual_diagram$(diagram_index).tex ]\u264e\n", color=:green, bold=true )
  visual_file = open( "visuals/visual_diagram$(diagram_index).tex", "w" )
  write( visual_file,
    "\\documentclass{revtex4}\n"*
    "\\usepackage{tikz-feynman}\n"*
    "\\usepackage{rotating}\n"*
    "\\usepackage{breqn}\n"*
    "\n"*
    "\\begin{document}\n"*
    "\n"*
    graph_str*
    "\n"*
    "\\end{document} \n"*
    "\n" )
  close( visual_file )


  expression_file = open( "visuals/expression_diagram$(diagram_index).m", "w" ) 
  write( expression_file, 
    "(* coupling factor: *) \n"*
    "$(couplingfactor_str)\n"*
    "\n" )

  n_color = length(color_str_list)
  for color_index ∈ 1:n_color
  write( expression_file,
    "(* color factor \\#$(color_index): *)\n"*
    "$(color_str_list[color_index])\n"*
    "\n"*
    "(* color factor coefficient \\#$(color_index): *)\n"*
    "\n"*
    "$(lorentz_str_list[color_index])\n"*
    "\n" )
  end # for color_index

  close( expression_file )

  return nothing

end # function write_out_visual_graph




##########################################################################
"""
    generate_amplitude( model::Model, input::Dict{Any,Any} )::Nothing

Generate amplitudes after `model` has been prepared.
"""
function generate_amplitude( model::Model, input::Dict{Any,Any} )::Nothing
##########################################################################

  n_loop = input["n_loop"]
  couplingfactor = Basic(input["couplingfactor"]) 

  file_stream = open("qgraf_out.dat")
  qgraf_out = YAML.load( file_stream )
  close( file_stream )

  qgraf_list = qgraf_out["FeynmanDiagrams"]

  #------------------------------------------------  
  # Convert qgraf to GenericGraph
  graph_set = Set{GenericGraph}()
  for one_qgraf in qgraf_list 

    g = convert_qgraf_TO_Graph( one_qgraf, model )
    if g == nothing 
      continue
    end # if

    push!( graph_set, g )
  end # for one_qgraf
  graph_list = sort( collect( graph_set ), by= g_->vertex_from_label("graph property",g_).attributes["diagram_index"] )


  #------------------------------------------------  
  # Generate Gauge choice
  gauge_choice = generate_gauge_choice( graph_list )
  # Generate kinematics relation
  kin_relation = generate_kin_relation( graph_list )
  file = open( "kin_relation.frm", "w" )
  write( file, join( map( ele_->"id $(ele_[1]) = $(ele_[2]);", collect(kin_relation) ), "\n" ) )
  close(file)

  ext_mom_list  = generate_ext_mom_list( graph_list )

  #------------------------------------------------  
  # Calculate amplitude for each graph

  file = open( "model_parameters.frm", "w" )
  write( file, "symbol "*join( map( k_->string(k_), collect(keys(model.parameter_dict)) ), "," )*";\n" )
  close(file)

  file = open( "contractor.frm", "w" )
  write( file, make_contractor_script() )
  close(file)

  file = open( "color.frm", "w" )
  write( file, make_color_script() )
  close(file)

  # baseINC only needs information from the external fields.
  file = open( "baseINC.frm", "w" )
  baseINC_script_str = make_baseINC_script( first(graph_list), gauge_choice )
  write( file, baseINC_script_str )
  close(file)

  if isdir( "visuals" )
    mv( "visuals", "visuals_$(now())" )
  end # if
  mkdir( "visuals" )
  cp( "../tikz-feynman.sty", "visuals/tikz-feynman.sty" )

  if isdir( "amplitudes" )
    mv( "amplitudes", "amplitudes_$(now())" )
  end # if
  mkdir( "amplitudes" )

  the_lock = ReentrantLock()

  now()
  #Threads.@threads for g in graph_list
  for g in graph_list
    diagram_index = vertex_from_label("graph property",g).attributes["diagram_index"]

    scale2_list = generate_scale2_list( g, kin_relation )

    amp_color_list, amp_lorentz_list = assemble_amplitude( g )
    amp_lorentz_list_pre, loop_den_list, loop_den_xpt_list = factor_out_loop_den( g, amp_lorentz_list )
    amp_lorentz_list = contract_Dirac_indices( g, amp_lorentz_list_pre )
    amp_lorentz_noexpand_list = contract_Dirac_indices_noexpand( g, amp_lorentz_list_pre )

    amp_color_list = simplify_color_factors( g, amp_color_list )

    #-------------------------------------------
    perm = sortperm( amp_color_list, by=gen_mma_str )
    amp_color_list = amp_color_list[perm]
    amp_lorentz_list = amp_lorentz_list[perm]

    write_out_amplitude( n_loop, diagram_index, couplingfactor, model.parameter_dict, ext_mom_list, scale2_list, kin_relation, baseINC_script_str,
                         amp_color_list, amp_lorentz_list, loop_den_list, loop_den_xpt_list, input["Amp_Min_Eps_Xpt"], input["Amp_Max_Eps_Xpt"], the_lock )


    write_out_visual_graph( g, model, couplingfactor, amp_color_list, amp_lorentz_noexpand_list, ext_mom_list, scale2_list )

    check_consistency( diagram_index, amp_lorentz_list, amp_lorentz_noexpand_list, ext_mom_list, kin_relation )

  end # for g
  now()


  # remove intermediate files
  rm( "baseINC.frm" )
  rm( "contractor.frm" )
  rm( "color.frm" )
  rm( "kin_relation.frm" )
  rm( "model_parameters.frm" )


  diagram_index_list = map( g_->vertex_from_label("graph property",g_).attributes["diagram_index"], graph_list )
  file = open( "visuals/generate_diagram_pdf.jl", "w" )
  write( file, "diagram_index_list = $(diagram_index_list)\n"*
               "for diagram_index in diagram_index_list\n"*
               "  run( `lualatex visual_diagram\$(diagram_index)` )\n"*
               "end\n" )
  close(file)
  printstyled( "\nUse script \"generate_diagram_pdf.jl\" to generate PDF files for all diagrams.\n\n", color=:green, bold=true )

  return nothing

end # function generate_amplitude





