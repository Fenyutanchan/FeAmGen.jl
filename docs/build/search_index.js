var documenterSearchIndex = {"docs":
[{"location":"#FeAmGen.jl-Documentation","page":"FeAmGen.jl Documentation","title":"FeAmGen.jl Documentation","text":"","category":"section"},{"location":"","page":"FeAmGen.jl Documentation","title":"FeAmGen.jl Documentation","text":"CurrentModule = FeAmGen","category":"page"},{"location":"","page":"FeAmGen.jl Documentation","title":"FeAmGen.jl Documentation","text":"","category":"page"},{"location":"#FeAmGen-Functions-in-Message.jl","page":"FeAmGen.jl Documentation","title":"FeAmGen Functions in Message.jl","text":"","category":"section"},{"location":"","page":"FeAmGen.jl Documentation","title":"FeAmGen.jl Documentation","text":"show_welcome_message\ngreen_message","category":"page"},{"location":"#FeAmGen.show_welcome_message","page":"FeAmGen.jl Documentation","title":"FeAmGen.show_welcome_message","text":"show_welcome_message()\n\nThis function gives information for users. Return nothing.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.green_message","page":"FeAmGen.jl Documentation","title":"FeAmGen.green_message","text":"green_message( statement::String, message::String )::Nothing\n\nPrint the statement in normal color and message in green. Return nothing.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen-Functions-in-Extra.jl","page":"FeAmGen.jl Documentation","title":"FeAmGen Functions in Extra.jl","text":"","category":"section"},{"location":"","page":"FeAmGen.jl Documentation","title":"FeAmGen.jl Documentation","text":"degree\nconvert_to_array\nmake_SP\ngen_mma_str","category":"page"},{"location":"#FeAmGen.degree","page":"FeAmGen.jl Documentation","title":"FeAmGen.degree","text":"degree( expr::Basic, x::Basic; max_n::Int64=100 )::Int64\n\nA little extension for SymEngine. This function degree calculate the degree of polynomial expr of x. For now we do not have toolkit to constraint expr as polynomial, so we only choose a maximum degree in the loop.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.convert_to_array","page":"FeAmGen.jl Documentation","title":"FeAmGen.convert_to_array","text":"convert_to_array( ::Val{:Symbol}, mom::Basic )::Array{NamedTuple{(:num, :ki),Tuple{Basic,Basic}}}\n\nThis specific convertion is applied only on single symbol momentum, e.g. k1.\n\nExamples\n\njulia> using SymEngine, FeAmGen\n\njulia> @vars k1\n(k1,)\n\njulia> FeAmGen.convert_to_array(k1)\n1-element Array{NamedTuple{(:num, :ki),Tuple{Basic,Basic}},1}:\n (num = 1, ki = k1)\n\n\n\n\n\nconvert_to_array( ::Val{:Mul}, mom::Basic )::Array{NamedTuple{(:num, :ki),Tuple{Basic,Basic}}}\n\nThis specific convertion is applied only on non-unit coefficient with single symbol momentum, e.g. 2*k1.\n\nExamples\n\njulia> using SymEngine, FeAmGen\n\njulia> @vars k1\n(k1,)\n\njulia> FeAmGen.convert_to_array(2*k1)\n1-element Array{NamedTuple{(:num, :ki),Tuple{Basic,Basic}},1}:\n (num = 2, ki = k1)\n\n\n\n\n\nconvert_to_array( ::Val{:Add}, mom::Basic )::Array{NamedTuple{(:num, :ki),Tuple{Basic,Basic}}}\n\nThis specific convertion is applied only on the summation of non-unit coefficient with single symbol momentum, e.g. 2*k1+3*k2+k3.\n\nExamples\n\njulia> using SymEngine, FeAmGen\n\njulia> @vars k1, k2, k3\n(k1, k2, k3)\n\njulia> FeAmGen.convert_to_array(2*k1+3*k2+k3)\n3-element Array{NamedTuple{(:num, :ki),Tuple{Basic,Basic}},1}:\n (num = 1, ki = k3)\n (num = 2, ki = k1)\n (num = 3, ki = k2)\n\n\n\n\n\nconvert_to_array( mom::Basic )::Array{NamedTuple{(:num, :ki),Tuple{Basic,Basic}}}\n\nThis is the interface to different specific convertion functions according to the class of mom. Now we assume there only there different classes of momentum mom. For example, \n\nk1\n2*k1\n2*k1+3*k2+k3\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.make_SP","page":"FeAmGen.jl Documentation","title":"FeAmGen.make_SP","text":"make_SP( mom1::Basic, mom2::Basic)::Basic\n\nThis function linearly expands the scalar product of mom1 and mom2. \n\nExamples\n\njulia> using SymEngine, FeAmGen\n\njulia> @vars k1, k2, k3\n(k1, k2, k3)\n\njulia> FeAmGen.make_SP( 2*k1+3*k2+k3, k1+k2 )\n2*SP(k1, k1) + 2*SP(k1, k2) + 3*SP(k2, k1) + 3*SP(k2, k2) + SP(k3, k1) + SP(k3, k2)\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.gen_mma_str","page":"FeAmGen.jl Documentation","title":"FeAmGen.gen_mma_str","text":"gen_mma_str( expr::Basic )::String\n\nThis is a generic interface for different classes of the expr. And it will generate the mathematica code for the expression expr.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen-Dict-and-Struct-in-Universe.jl","page":"FeAmGen.jl Documentation","title":"FeAmGen Dict and Struct in Universe.jl","text":"","category":"section"},{"location":"","page":"FeAmGen.jl Documentation","title":"FeAmGen.jl Documentation","text":"color_dict\nspin_dict\ncharge_convert\nParticle\nInteraction\nModel\nis_anticommuting\nis_neutral\nis_not_majorana\nis_massless\nis_massive\nis_gluon\nis_photon\nis_massless_quark\nis_top_quark\nis_ghost\nis_quark\nis_colorful\nis_not_colorful\nis_massive_fermion\nto_string\nfind_AC_pair_pos\ngenerate_ordered_link_list\nto_qgraf_name\ngenerate_QGRAF_model\nlogging_model","category":"page"},{"location":"#FeAmGen.color_dict","page":"FeAmGen.jl Documentation","title":"FeAmGen.color_dict","text":"const Dict color_dict\n\nDict( 1=>:singlet, 3=>:triplet, -3=>:triplet, 8=>:octet )\n\n\n\n\n\n","category":"constant"},{"location":"#FeAmGen.spin_dict","page":"FeAmGen.jl Documentation","title":"FeAmGen.spin_dict","text":"const Dict spin_dict\n\nDict( 1=>:scalar, -1=>:ghost, 2=>:fermion, 3=>:vector )\n\n\n\n\n\n","category":"constant"},{"location":"#FeAmGen.charge_convert","page":"FeAmGen.jl Documentation","title":"FeAmGen.charge_convert","text":"charge_convert( model_charge::Float64 )::Rational{Int64}\n\nConvert the float number of charge in the model file into a rational number, especially the quark charge.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.Particle","page":"FeAmGen.jl Documentation","title":"FeAmGen.Particle","text":"struct Particle\n\n  kf::Int64\n  name::String\n  antiname::String\n  spin::Symbol\n  color::Symbol\n  charge::Rational{Int64}\n  mass::Basic\n  width::Basic\n\n\n\n\n\n","category":"type"},{"location":"#FeAmGen.Interaction","page":"FeAmGen.jl Documentation","title":"FeAmGen.Interaction","text":"struct Interaction\n\n  name::String\n  # UFO convention is outgoing particle, but in our convention is incoming\n  link_list::Vector{Particle}\n  color_row_list::Vector{Basic} # 1xN\n  lorentz_col_list::Vector{Basic} # Mx1\n  couplings_matrix::Array{Basic,2} # NxM\n  QCD_order::Int64\n  QED_order::Int64\n\n\n\n\n\n","category":"type"},{"location":"#FeAmGen.Model","page":"FeAmGen.jl Documentation","title":"FeAmGen.Model","text":"struct Model\n\n  name::String\n  unitary_gauge::Bool\n  particle_list::Vector{Particle}\n  particle_name_dict::Dict{String,Particle}\n  particle_kf_dict::Dict{Int64,Particle}\n  interaction_list::Vector{Interaction}\n  sorted_kf_list_dict::Dict{Vector{Int64},Interaction}\n  parameter_dict::Dict{Basic,Basic}\n\n\n\n\n\n","category":"type"},{"location":"#FeAmGen.is_anticommuting","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_anticommuting","text":"is_anticommuting( part::Particle )::Bool\n\nFunction \"is_anticommuting\" is used for the sign in the calculation of fermion/ghost loop. The problem is according to Paulo Nogueira, we can have our own definition for the sign of majorana loop.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_neutral","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_neutral","text":"is_neutral( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_not_majorana","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_not_majorana","text":"is_not_majorana( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_massless","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_massless","text":"is_massless( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_massive","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_massive","text":"is_massive( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_gluon","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_gluon","text":"is_gluon( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_photon","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_photon","text":"is_photon( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_massless_quark","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_massless_quark","text":"is_massless_quark( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_top_quark","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_top_quark","text":"is_top_quark( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_ghost","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_ghost","text":"is_ghost( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_quark","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_quark","text":"is_quark( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_colorful","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_colorful","text":"is_colorful( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_not_colorful","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_not_colorful","text":"is_not_colorful( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.is_massive_fermion","page":"FeAmGen.jl Documentation","title":"FeAmGen.is_massive_fermion","text":"is_massive_fermion( part::Particle )::Bool\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.to_string","page":"FeAmGen.jl Documentation","title":"FeAmGen.to_string","text":"to_string( inter::Interaction )::String\n\nConvert Interaction to string for writing out.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.find_AC_pair_pos","page":"FeAmGen.jl Documentation","title":"FeAmGen.find_AC_pair_pos","text":"find_AC_pair_pos( part_list::Vector{Particle} )::Union{Tuple{Nothing,Nothing},Tuple{Int64,Int64}}\n\nThis function is used to find the pair of anti-commuting particles/fields. This information will be inserted into QGRAF model, so that QGRAF can generate correct sign for anti-commuting particle loop. For example, we should have extra minus sign for fermion loop and ghost loop.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.generate_ordered_link_list","page":"FeAmGen.jl Documentation","title":"FeAmGen.generate_ordered_link_list","text":"generate_ordered_link_list( part_list::Vector{Particle} )::Vector{Particle}\n\nThis function is used to generate order particle list according to the rule of QGRAF.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.to_qgraf_name","page":"FeAmGen.jl Documentation","title":"FeAmGen.to_qgraf_name","text":"to_qgraf_name( name_str::String )::String\n\nChange the particle name into the one that QGRAF can accept.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.generate_QGRAF_model","page":"FeAmGen.jl Documentation","title":"FeAmGen.generate_QGRAF_model","text":"generate_QGRAF_model( model::Model )::Nothing\n\nWrite out the model file that can be used by QGRAF.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.logging_model","page":"FeAmGen.jl Documentation","title":"FeAmGen.logging_model","text":"logging_model( model::Model )::Nothing\n\nWrite out model file that contains more detail.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen-functions-in-SimpleDigest.jl","page":"FeAmGen.jl Documentation","title":"FeAmGen functions in SimpleDigest.jl","text":"","category":"section"},{"location":"","page":"FeAmGen.jl Documentation","title":"FeAmGen.jl Documentation","text":"electron_num\nmu_num\ntau_num\nquark1st_num\nquark2nd_num\nquark3rd_num","category":"page"},{"location":"#FeAmGen.electron_num","page":"FeAmGen.jl Documentation","title":"FeAmGen.electron_num","text":"electron_num( part::Particle )::Int64\n\nCount the electron number (lepton number in 1st generation ).\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.mu_num","page":"FeAmGen.jl Documentation","title":"FeAmGen.mu_num","text":"mu_num( part::Particle )::Int64\n\nCount the muon number (lepton number in 2nd generation ).\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.tau_num","page":"FeAmGen.jl Documentation","title":"FeAmGen.tau_num","text":"tau_num( part::Particle )::Int64\n\nCount the tauon number (lepton number in 3rd generation ).\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.quark1st_num","page":"FeAmGen.jl Documentation","title":"FeAmGen.quark1st_num","text":"quark1st_num( part::Particle )::Int64\n\nCount the quark flavor number in 1st generation. This is used for the case that has no flavor violation.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.quark2nd_num","page":"FeAmGen.jl Documentation","title":"FeAmGen.quark2nd_num","text":"quark2nd_num( part::Particle )::Int64\n\nCount the quark flavor number in 2nd generation. This is used for the case that has no flavor violation.\n\n\n\n\n\n","category":"function"},{"location":"#FeAmGen.quark3rd_num","page":"FeAmGen.jl Documentation","title":"FeAmGen.quark3rd_num","text":"quark3rd_num( part::Particle )::Int64\n\nCount the quark flavor number in 3rd generation. This is used for the case that has no flavor violation.\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"FeAmGen.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"FeAmGen.jl Documentation","title":"FeAmGen.jl Documentation","text":"","category":"page"}]
}
